
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<title>Spring Boot サンプルアプリ作成</title>
<title>Spring Boot Development Reference</title>
</head>
<body id="Tutorial" class="book toc2 toc-left">
<div id="header">
<h1>Spring Boot サンプルアプリ作成</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#env">1. 環境整備</a>
<ul class="sectlevel2">
<li><a href="#apiclient">1.1 API実行クライアント</a>
<li><a href="#ide">1.2 統合開発環境</a>
</ul>
<li><a href="#createproj">2. プロジェクトの作成</a>
<li><a href="#commitproj">3. プロジェクトのコミット</a>
<li><a href="#importproj">4. プロジェクトのインポート</a>
<li><a href="#createapi">5. REST APIの作成</a>
<ul>
    <li><a href="#initset">5.1 初期設定</a>
    <ul>
        <li><a href="#configurepom">5.1.1 pom.xmlの設定</a>
        <li><a href="#configureyaml">5.1.2 application.yamlの設定</a>
    </ul>
    <li><a href="#createpkg">5.2. パッケージのの作成</a>
    <li><a href="#createsrcfld">5.3. ソースフォルダの作成</a>
    <li><a href="#createtodo">5.4. Todoクラスの作成</a>
    <li><a href="#createtodoresrc">5.5. TodoResourceクラスの作成</a>
    <li><a href="#createtorepo">5.6. Repositoryクラスの作成</a>
    <ul>
        <li><a href="#createtable">5.6.1 テーブルの作成</a>
        <li><a href="#createtodorepository">5.6.2 TodoRepositoryインターフェースの作成</a>
        <li><a href="#testrepo">5.6.3 Repositoryの単体テスト</a>
        <ul>
            <li><a href="#createinitdata">5.6.3.1 初期データの作成</a>
            <li><a href="#createtest">5.6.3.2 Spring Testの標準機能を利用したTestの実装</a> 
            <li><a href="#dotest">5.6.3.3 RepositoryTestの実行</a>
        </ul>
    </ul>
    <li><a href="#createservice">5.7. Serviceクラスの作成</a>

</ul>

</div>
</div>
<div id="content">
<h2 id="env"><a class="anchor" href="#env"></a>1. 環境整備</h2>
<p>サンプルアプリを作成するための環境構築を以下の手順で行う。</p>
</div>
<ul class="sectlevel1">
<h3 id="apiclient"><a class="anchor" href="#apicliect"></a>1.1 API実行クライアント</h3>
<p> 
    API実行クライアントにはTalent API Testerを利用する。インストール方法は以下の通り。
</p>
</ul>
<ul class="sectlevel1">
<ol>
    <li type=I>
        <a href="https://chrome.google.com/webstore/detail/talend-api-tester-free-ed/aejoelaoggembcahagimdiliamlcdmfm?hl=ja">
            Talemt API Testerのインストール先にアクセス
        </a>
    </li>
    <li type=I>
        画面右上の「Chromeに追加」を押下。
    </li>
    <li type=I>
        Chromeに正常に追加されたら、画面右上の拡張機能のアイコンよりTalent API Testerを押下する。
    </li>
    <li type=I>
        リクエスト生成画面が表示されたら動作確認完了。
    </li>
</ol>
</ul>
<ul>
<h3 id="ide"><a class="anchor" href="#ide"></a>1.2 統合開発環境</h3>
<p>統合開発環境には、Terasolunaチュートリアル実施時にインストール済みのSTS4.3を利用する。</p>
</ul>
<h2 id="createproj"><a class="anchor" href="#createproj"></a>2. プロジェクトの作成</h2>
<p>
    <a href="https://start.spring.io/">Spring Initializr</a>
    を利用して、Spring Bootのプロジェクトを作成する。手順を以下に示す。
    <ul class="sectlevel1">
        <ol>
            <li type=I>
                <a href="https://start.spring.io/">Spring Initializr</a>
                にアクセスする。
                </a>
            </li>
            <li type=I>
                Spring Initializrの設定画面が表示される。以下の設定値を入力する。
                <ul>
                <p>
                    <table border=1  width=1000>
                        <tr>
                            <th colspan=2>項目名</th>
                            <th>設定値</th>
                            <th>備考</th>
                        </tr>
                        <tr>
                            <td colspan=2>Project</td>
                            <td>Maven Project</td>
                            <td>Mavenでビルドする設定とする。</td>
                        </tr>
                        <tr>
                            <td colspan=2>Language</td>
                            <td>Java</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td colspan=2>Spring Boot</td>
                            <td>2.5.6</td>
                            <td></td>
                        </tr>
                        <tr><td rowspan="8">Project Metadata</td></tr>
                        <tr>
                            <td>Group</td>
                            <td>com.example</td>
                            <td>パッケージを提供するグループを指定する。</td>
                        </tr>
                        <tr>
                            <td>Artifact</td>
                            <td>tutorial</td>
                            <td>プロジェクトの成果物の名前  </td>
                        </tr>
                        <tr>
                            <td>Name</td>
                            <td>tutorial</td>
                            <td>プロジェクトの表示名。 ドキュメントを作成するときなどに使用されます。</td>
                        </tr>
                        <tr>
                            <td>Desription</td>
                            <td>tutorial Project</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Package name</td>
                            <td>com.exaple.tutorial</td>
                            <td>パッケージ名</td>
                        </tr>
                        <tr>
                            <td>Packaging</td>
                            <td>Jar</td>
                            <td>WARでパッケージ化するか、Jarでパッケージ化するかを選択。Jarでパッケージ化すると実行環境を組み込める。</td>
                        </tr>
                        <tr>
                            <td>Java</td>
                            <td>8</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td colspan=2 rowspan=5>
                                Dependancies
                                <br>
                                ※画面右上のADD DEPENDANCIES...から追加
                            </td>
                        </tr>
                        <tr>
                            <td>SpringWeb</td>
                            <td>Webアプリのライブラリ</td>
                        </tr>
                        <tr>
                            <td>Lombok</td>
                            <td>開発効率化のためのソース自動生成ライブラリ</td>
                        </tr>
                        <tr>
                            <td>H2 Database</td>
                            <td>インメモリデータベース</td>
                        </tr>
                        <tr>
                            <td>MyBatis Framework</td>
                            <td>データベースアクセスのフレームワーク</td>
                        </tr>
                    </table>
                </p>
                </ul>
                <li type=I>
                画面下部の GENERATE + ⏎ をクリックする。tutorial.zipがダウンロードされる。
                <li type=I>
                ダウンロードしたzipファイルを作業フォルダで展開する。
                <li type=I>
                展開フォルダ上で以下のコマンドを実行し、動作確認を行う。
                <pre><code>mvn spring-boot:run</code></pre>
                【表示例】
                <pre><code>
                    .
                    .
                    ...pom.xmlに記載のパッケージダウンロード処理
                    .
                    .
                    [INFO] Attaching agents: []

                    .   ____          _            __ _ _
                   /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
                  ( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
                   \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
                    '  |____| .__|_| |_|_| |_\__, | / / / /
                   =========|_|==============|___/=/_/_/_/
                   :: Spring Boot ::                (v2.5.6)
                  
                  2021-11-10 01:47:34.489  INFO 11544 --- [           main] c.example.turorial.TurorialApplication   : Starting TurorialApplication using Java 14.0.2 on DESKTOP-VU8QFTR with PID 11544 (C:\study\spring\springboot▒`▒▒▒[▒g▒▒▒A▒▒\▒A▒v▒▒▒쐬\turorial\target\classes started by user in C:\study\spring\springboot▒`▒▒▒[▒g▒▒▒A▒▒\▒A▒v▒▒▒쐬\turorial)
                  2021-11-10 01:47:34.505  INFO 11544 --- [           main] c.example.turorial.TurorialApplication   : No active profile set, falling back to default profiles: default
                  2021-11-10 01:47:35.237  WARN 11544 --- [           main] o.m.s.mapper.ClassPathMapperScanner      : No MyBatis mapper was found in '[com.example.turorial]' package. Please check your configuration.
                  2021-11-10 01:47:35.725  INFO 11544 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 8080 (http)
                  2021-11-10 01:47:35.741  INFO 11544 --- [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]
                  2021-11-10 01:47:35.741  INFO 11544 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet engine: [Apache Tomcat/9.0.54]
                  2021-11-10 01:47:35.841  INFO 11544 --- [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
                  2021-11-10 01:47:35.841  INFO 11544 --- [           main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 1267 ms
                  2021-11-10 01:47:36.382  INFO 11544 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path ''
                  2021-11-10 01:47:36.398  INFO 11544 --- [           main] c.example.turorial.TurorialApplication   : Started TurorialApplication in 2.452 seconds (JVM running for 2.899)
                    
                </code></pre>
            </li>
        </ol>
        </ul>
</p>
<h2 id="commitproj"><a class="anchor" href="#commitproj"></a>3. プロジェクトのコミット</h2>
以下手順で作成したSprin BootプロジェクトをGitHubにコミットする。
<ul>
    <ol>
        <li>GitHub上で新規リポジトリを作成する。</li>
        <li>
            以下コマンドでプロジェクトを初期化し、GitHubにpushする。
            <pre><code>
                git init
                echo "# Study Spring Boot" >> README.md
                git add .
                git commit -m "first commit"
                git remote add origin git@github.com:yushin1402/spring-boot.git
                git push -u origin master
            </code></pre>
        </li>
    </ol>
</ul>
<h2 id="importproj"><a class="anchor" href="#importproj"></a>4. プロジェクトのインポート</h2>
以下手順で作成したSprin BootプロジェクトをSTSにインポートする。
<ul>
    <ol>
        <li>ワークスペースに指定するフォルダを作成する。</li>
        <li>作成したフォルダをワークスペースに指定してSTSを起動する。</li>
        <li>ファイル→インポート→Maven>既存Mavenプロジェクトを選んで、次へをクリックする。</li>
        <li>作成したプロジェクトフォルダを選択し、完了する。(pom.xmlがあるフォルダ)</li>
        <li>パッケージエクスプローラにtutorialプロジェクトが表示されたことを確認する。</li>
        <li>
            パッケージを右クリック→実行→SpringBootアプリケーションをクリックし、アプリケーションを起動して動作確認を行う。
            <br>
            以下のようなログがSTSのコンソールに出力され、正常に起動したことを確認出来ればOK。
            <pre><code>
                 .   ____          _            __ _ _
                 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
                ( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
                 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
                  '  |____| .__|_| |_|_| |_\__, | / / / /
                 =========|_|==============|___/=/_/_/_/
                [32m :: Spring Boot :: [39m              [2m (v2.5.6)[0;39m

                [2m2021-11-10 02:48:52.487[0;39m [32m INFO[0;39m [35m12080[0;39m [2m---[0;39m [2m[           main][0;39m [36mc.example.turorial.TurorialApplication  [0;39m [2m:[0;39m Starting TurorialApplication using Java 16.0.2 on DESKTOP-VU8QFTR with PID 12080 (C:\study\spring\springbootチュートリアル\アプリ作成\turorial\target\classes started by user in C:\study\spring\springbootチュートリアル\アプリ作成\turorial)
                [2m2021-11-10 02:48:52.493[0;39m [32m INFO[0;39m [35m12080[0;39m [2m---[0;39m [2m[           main][0;39m [36mc.example.turorial.TurorialApplication  [0;39m [2m:[0;39m No active profile set, falling back to default profiles: default
                [2m2021-11-10 02:48:53.254[0;39m [33m WARN[0;39m [35m12080[0;39m [2m---[0;39m [2m[           main][0;39m [36mo.m.s.mapper.ClassPathMapperScanner     [0;39m [2m:[0;39m No MyBatis mapper was found in '[com.example.turorial]' package. Please check your configuration.
                [2m2021-11-10 02:48:53.681[0;39m [32m INFO[0;39m [35m12080[0;39m [2m---[0;39m [2m[           main][0;39m [36mo.s.b.w.embedded.tomcat.TomcatWebServer [0;39m [2m:[0;39m Tomcat initialized with port(s): 8080 (http)
                [2m2021-11-10 02:48:53.691[0;39m [32m INFO[0;39m [35m12080[0;39m [2m---[0;39m [2m[           main][0;39m [36mo.apache.catalina.core.StandardService  [0;39m [2m:[0;39m Starting service [Tomcat]
                [2m2021-11-10 02:48:53.692[0;39m [32m INFO[0;39m [35m12080[0;39m [2m---[0;39m [2m[           main][0;39m [36morg.apache.catalina.core.StandardEngine [0;39m [2m:[0;39m Starting Servlet engine: [Apache Tomcat/9.0.54]
                [2m2021-11-10 02:48:53.779[0;39m [32m INFO[0;39m [35m12080[0;39m [2m---[0;39m [2m[           main][0;39m [36mo.a.c.c.C.[Tomcat].[localhost].[/]      [0;39m [2m:[0;39m Initializing Spring embedded WebApplicationContext
                [2m2021-11-10 02:48:53.779[0;39m [32m INFO[0;39m [35m12080[0;39m [2m---[0;39m [2m[           main][0;39m [36mw.s.c.ServletWebServerApplicationContext[0;39m [2m:[0;39m Root WebApplicationContext: initialization completed in 1226 ms
                [2m2021-11-10 02:48:54.413[0;39m [32m INFO[0;39m [35m12080[0;39m [2m---[0;39m [2m[           main][0;39m [36mo.s.b.w.embedded.tomcat.TomcatWebServer [0;39m [2m:[0;39m Tomcat started on port(s): 8080 (http) with context path ''
                [2m2021-11-10 02:48:54.424[0;39m [32m INFO[0;39m [35m12080[0;39m [2m---[0;39m [2m[           main][0;39m [36mc.example.turorial.TurorialApplication  [0;39m [2m:[0;39m Started TurorialApplication in 2.392 seconds (JVM running for 3.347)
            </code></pre>
            
            ※<code>maven spring-boot:run</code>でテスト起動したアプリケーションが停止出来ていなかったため、以下のエラー出力となった。
            <pre><code>
                ***************************
                APPLICATION FAILED TO START
                ***************************

                Description:

                Web server failed to start. Port 8080 was already in use.
            </code></pre>
            <code>netstat</code>コマンドで8080ポートをListenしているプロセスを特定し、タスクマネージャから終了することで対応した。
        </li> 
               
    </ol>
</ul>
<h2 id="createapi"><a class="anchor" href="#createapi"></a>5. REST APIの作成</h2>
<ul>
    <h2 id="initset"><a class="anchor" href="#initset"></a>5.1 初期設定</h2>
    <ul>
         <h3 id="configurepom"><a class="anchor" href="#configurepom"></a>5.1.1 pom.xmlの設定</h2>
        以下の定義をpom.xmlに設定する。
        <pre><code>
            &lt;dependency&gt;
                &lt;groupId&gt;com.github.dozermapper&lt;/groupId&gt;
                &lt;artifactId&gt;dozer-spring-boot-starter&lt;/artifactId&gt;
                &lt;version&gt;6.5.0&lt;/version&gt;
            &lt;/dependency&gt;
            ↑↑  オブジェクトからオブジェクトにデータをコピーするマッピングフレームワーク。
                コピー元からコピー先に同じ属性値がある限り、値をコピーする。この際、型が異なる場合は自動変換してくれる。
                通常、このような処理を行うにはgetterメソッドとsetterメソッドの呼び出しが必要だが、Dozerを利用することで
                コードを簡略化できる。  　　
            &lt;dependency&gt;
                &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
                &lt;artifactId&gt;mybatis-spring-boot-starter-test&lt;/artifactId&gt;
                &lt;version&gt;2.1.0&lt;/version&gt;
                &lt;scope&gt;test&lt;/scope&gt;
            &lt;/dependency&gt;
            ↑↑ MyBatisの機能をテストするライブラリ   
        </code></pre>
    </ul>
    <ul>
        <h2 id="configureyaml"><a class="anchor" href="#configureyaml"></a>5.1.2 application.ymlの設定</h2>  
            application.yamlでSpring Boot起動時に生成されるBeanの設定を変更することで、アプリケーションのプロパティ設定を行うことが出来る。
            ログ出力のプロパティ設定、トランザクションのプロパティ設定、データのプロパティ設定などを変更出来る。
            <br>
            参考：<a href="https://spring.pleiades.io/spring-boot/docs/current/reference/html/application-properties.html">アプリケーションプロパティ設定一覧</a>
            <br>
            今回は以下の通り、MybatisのSnakeCaseで定義されたカラム名をCamelCaseに変換(例：camel-case→camelCase)し、Formオブジェクトのプロパティ名とデータベースのカラム名をマッピングする設定を有効化する。
            (yaml形式で記述するため、src/main/resources/下にあるapplication.propertiesをapplication.ymlにリネームした上で設定を記述する。)
            <pre><code>
                mybatis:
                  configuration:
                    mapUnderscoreToCamelCase: true
            </code></pre>
    </ul>
    <h2 id="createpkg"><a class="anchor" href="#createpkg"></a>5.2 パッケージの作成</h2>
        以下の構成でパッケージを作成する。
        <pre><code>
            ├─src
            │  ├─main
            │  │  ├─java
            │  │  │  └─com
            │  │  │      └─example
            │  │  │          └─tutorial              
            │  │  │              ├─common             
            │  │  │              │  └─exception      ←新規作成パッケージ
            │  │  │              └─todo               ←新規作成パッケージ
            │  └─test
            │      └─java
            │          └─com
            │              └─example
            │                  └─tutorial               
            │                      └─todo              ←新規作成パッケージ
            
        </code></pre>
        パッケージはSTSのパッケージエクスプローラ上でtutrialパッケージを右クリック→新規→パッケージと選択し、
        パッケージ作成場所のフォルダとパッケージ名を指定して作成する。
        パッケージ名は、フォルダ階層に合わせて指定する。(exceptionパッケージの場合は「com.example.tutorial.common.exeption」)

        <h2 id="createsrcfld"><a class="anchor" href="#createsrcfld"></a>5.3 ソースフォルダの作成</h2>
            テスト用の初期データを格納するソースフォルダを作成する。(プロジェクト名:tutorial、フォルダ名:src/test/resources)
            <br>
            ソースフォルダとはJavaのコードを格納するフォルダ。Javaの世界ではパッケージとソースフォルダを明に区別する。
            <br>
            <ul>
            <li>パッケージ</li>
            クラスをグループ化したもの。コンパイル時はパッケージの構成に従って、実行体が生成されていく理解。
            <li>ソースフォルダ</li>
            ソースをグループ化したもの。
            <br>
        </ul>
            なお、パッケージもソースフォルダも実態はただのフォルダだが、STSやmavenは.classpathの記述内容を参照して区別している。
            <pre><code>
                &lt;classpathentry kind="src" output="target/classes" path="src/main/java"&gt;
                    &lt;attributes&gt;
                        &lt;attribute name="optional" value="true"/&gt;
                        &lt;attribute name="maven.pomderived" value="true"/&gt;
                    &lt;/attributes&gt;
                &lt;/classpathentry&gt;
            </code></pre> 
            
            今回作成したソースフォルダはテスト用ソースを格納するためのものである。Mavenビルド時にテストを実行させるため、
            このフォルダをテスト用ソースフォルダとしてMavenに認識させる。手順は以下の通り。
            <ol>
                <li>STSの画面上のパッケージエクスプローラを右クリック</li>
                <li>Maven(M)を選択</li>
                <li>プロジェクトの更新を選択</li>
                <li>src/test/resourcesにアイコンが追加されたことを確認</li>
            </ol>
            <h2 id="createtodo"><a class="anchor" href="#createtodo"></a>5.4 Todoクラスの作成</h2>
            パッケージやソースフォルダを作成した方法と同じ要領でTodoクラスを作成する。
             <table width=500>
                 <tr>
                     <th>項目名</th>
                     <th>設定値</th>
                 </tr>
                 <tr>
                     <td>Source Folder</td>
                     <td>turorial/src/main/java</td>
                 </tr>
                 <tr>
                    <td>Package</td>
                    <td>com.example.tutorial.todo</td>
                </tr>
                <tr>
                    <td>Name</td>
                    <td>Todo</td>
                </tr>
                <tr>
                    <td>interfaces</td>
                    <td>java.io.Serializable</td>
                </tr>
             </table>
             作成したTodo.javaは、～を生成するクラスとなる。このため、インターフェース情報を定義するプロパティと
             プロパティにアクセスするSetterとGetterの実装が必要となる。また、プロパティの初期化を行うコンストラクタの実装も必要である。
             <br>
             これらの処理はLombok提供のアノテーションを記述するだけで実装可能。以下がサンプルコードとなる。
             <pre><code>
                package com.example.tutorial.todo;

                import java.io.Serializable;
                import java.time.LocalDateTime;
                import lombok.AllArgsConstructor;
                import lombok.Getter;
                import lombok.NoArgsConstructor;
                import lombok.Setter;
                
                @Getter //下記プロパティにアクセスするGetterメソッドをSpringBoot起動時に実装してくれる。
                @Setter　//下記プロパティにアクセスするSettersメソッドをSpringBoot起動時に実装してくれる。
                @AllArgsConstructor　//下記の全プロパティに初期値を設定するコンストラクタをSpringBoot起動時に実装してくれる。
                @NoArgsConstructor　//引数なしのコンストラクタ(デフォルトコンストラクタ)を実装してくれる。
                
                public class Todo implements Serializable {
                    private static final long serialVersionUID = 1L;　//この後実装するREST APIで利用するインターフェース値
                 
                    private Long todoId; //この後実装するREST APIで利用するインターフェース値
                
                    private String todoTitle;　//この後実装するREST APIで利用するインターフェース値
                
                    private boolean finished;　//この後実装するREST APIで利用するインターフェース値
                
                    private LocalDateTime createdAt;　//この後実装するREST APIで利用するインターフェース値
                }
               </code></pre>
             <h2 id="createtodoresrc"><a class="anchor" href="#createtodoresrc"></a>5.5 TodoResourceクラスの作成</h2>
             クライアントとの入出力に使用するインターフェースとして、TodoResourceクラスを作成する。
             インターフェースのデータ表現形式にはJSONを利用する。TodoReourceクラスは、JSONを解析し、オブジェクト化する。
             <table width=500>
                <tr>
                    <th>項目名</th>
                    <th>設定値</th>
                </tr>
                <tr>
                    <td>Source Folder</td>
                    <td>turorial/src/main/java</td>
                </tr>
                <tr>
                   <td>Package</td>
                   <td>com.example.tutorial.todo</td>
               </tr>
               <tr>
                   <td>Name</td>
                   <td>TodoResource</td>
               </tr>
               <tr>
                   <td>interfaces</td>
                   <td>java.io.Serializable</td>
               </tr>
            </table>
            以下のコードを記述する。なお、最新のmavenでは、javax.validationがインポートされていないため、pom.xmlに依存関係の定義を追加する必要がある。
            <pre><code>
                package com.example.tutorial.todo;

                import java.io.Serializable;
                import java.time.LocalDateTime;
                import javax.validation.constraints.NotEmpty;
                import javax.validation.constraints.Size;
                import com.fasterxml.jackson.annotation.JsonFormat;
                import lombok.AllArgsConstructor;
                import lombok.Getter;
                import lombok.NoArgsConstructor;
                import lombok.Setter;
                
                @Getter
                @Setter
                @AllArgsConstructor
                @NoArgsConstructor
                public class TodoResource implements Serializable {
                
                    private static final long serialVersionUID = 1L;
                
                    private Long todoId;
                
                    @NotEmpty  // validationチェックのアノテーション。このクラスでクライアントからの入力をチェックし、エラー判定する。
                    @Size(max = 30)　// validationチェックのアノテーション。このクラスでクライアントからの入力をチェックし、エラー判定する。
                    private String todoTitle;
                
                    private boolean finished;
                
                    @JsonFormat(pattern = "uuuu/MM/dd HH:mm:ss")　// 日付フォーマットの指定。
                    private LocalDateTime createdAt;
                
                }                
            </code></pre>
            pom.xmlに追加したコード
            <pre><code>
                &lt;dependency&gt;
                    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                    &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;
              &lt;/dependency&gt;
            </code></pre>   
            <h2 id="createrepo"><a class="anchor" href="#createrepo"></a>5.6 Repositoryクラスの作成</h2>
            MyBaticを利用してデータベースアクセスを行うための実装と設定を行う。
            <ul>
                <h2 id="createtable"><a class="anchor" href="#createtable"></a>5.6.1 テーブルの作成</h2>
                H2を利用する。H2についてはデフォルトでデータソース設定済みのため、そのまま利用出来る。
                その他のデータベース(Postgresなど)を利用する場合は「application.yaml」で接続設定を行う。
                <br>
                todoターブルを作成するSQLファイルを作成する。
                <table width=500>
                    <tr>
                        <th>項目名</th>
                        <th>設定値</th>
                    </tr>
                    <tr>
                        <td>親フォルダ</td>
                        <td>turorial/src/main/resources</td>
                    </tr>
                    <tr>
                       <td>ファイル名</td>
                       <td>schema.sql</td>
                   </tr>
                </table>
                作成したファイルに以下のSQLを記述する。
                <pre><code>
                    CREATE TABLE IF NOT EXISTS todo (
                        todo_id BIGINT IDENTITY PRIMARY KEY,
                        todo_title VARCHAR(30),
                        finished BOOLEAN,
                        created_at TIMESTAMP
                      );                    
                </code></pre>
                <h2 id="createtodorepo"><a class="anchor" href="#createtodorepo"></a>5.6.2 TodoRepositoryインターフェースの作成</h2>
                MyBaticを利用してデータベースにアクセスするためのインターフェースを作成する。
                <table width=500>
                    <tr>
                        <th>項目名</th>
                        <th>設定値</th>
                    </tr>
                    <tr>
                        <td>ソースフォルダ</td>
                        <td>turorial/src/main/java</td>
                    </tr>
                    <tr>
                       <td>パッケージ</td>
                       <td>com.example.tutorial.todo</td>
                   </tr>
                   <tr>
                       <td>名前</td>
                        <td>TodoRepository</td>
                    </tr>
                </table>
                作成したインターフェースにデータベースを操作するためのメソッドを記述する。
                <pre><code>
                    package com.example.tutorial.todo;

                    import java.util.Collection;
                    import java.util.Optional;
                    import org.apache.ibatis.annotations.Delete;
                    import org.apache.ibatis.annotations.Insert;
                    import org.apache.ibatis.annotations.Mapper;
                    import org.apache.ibatis.annotations.Options;
                    import org.apache.ibatis.annotations.Select;
                    import org.apache.ibatis.annotations.Update;
                    
                    @Mapper // (1)
                    public interface TodoRepository {
                    
                        @Select("SELECT todo_id, todo_title, finished, created_at FROM todo WHERE todo_id = #{todoId}") // (2)
                        Optional<Todo> findById(Long todoId);
                    
                        @Select("SELECT todo_id, todo_title, finished, created_at FROM todo")
                        Collection<Todo> findAll();
                    
                        @Insert("INSERT INTO todo(todo_title, finished, created_at) VALUES(#{todoTitle}, #{finished}, #{createdAt})")
                        @Options(useGeneratedKeys = true, keyProperty = "todoId")
                        void create(Todo todo);
                    
                        @Update("UPDATE todo SET finished = true WHERE todo_id = #{todoId}")
                        long updateById(Long todoId);
                    
                        @Delete("DELETE FROM todo WHERE todo_id = #{todoId}")
                        long deleteById(Long todoId);
                    
                        @Select("SELECT COUNT(*) FROM todo WHERE finished = #{finished}")
                        long countByFinished(boolean finished);
                    }
                </code></pre>
                上記コードはMyBaticを利用するためのアノテーションや型を利用することでデータ操作を実現している。
                以下に各アノテーションについて記載する。
                <table width=500>
                    <tr>
                        <th>項目名</th>
                        <th>意味</th>
                    </tr>
                    <tr>
                        <td>@Mapper</td>
                        <td>MyBatisでリポジトリを作成する際は、インターフェースに@Mapperを記述する。MyBaticはJavaインターフェースとxmlファイルをマッピングすることでSQLをxmlファイルで管理することが出来るため、@Mapperを利用するが、今回はマッピングはせず、SQLをJavaインターフェースに直接書き込む。</td>
                    </tr>
                    <tr>
                       <td>@Select</td>
                       <td>Select文を記述する。Where句の対象に#{todoId}と記述があるが、これは、アノテーションが付与されたメソッドで返却されるオブジェクトのプロパティ名とマッピングされる。今回は作成済みのTodo.javaで定義したTodoクラスのプロパティとマッピングされている。なお、MyBaticのカラム名はスネークケースとなっているが、application.yamlでCamelCaseへの変換定義を行っている。</td>
                   </tr>
                   <tr>
                    <td>@Options</td>
                    <td>データ操作時のオプション設定を記述する。useGeneratedKeysは、データベース側で自動生成されたキーを自動取得する設定としている。取得されたキーはkeyPropertyに設定したプロパティ名で受け取ることができる。</td>
                </tr>
                </table>
                <h2 id="testrepo"><a class="anchor" href="#testrepo"></a>5.6.3 Repositoryの単体テスト</h2>
                SpringBoot提供のアノテーションを利用してテストを行う。
                <ul>
                    <h2 id="createinitdata"><a class="anchor" href="#createinitdata"></a>5.6.3.1 初期データの作成</h2>
                    tutorial/src/test/resources配下にdata.sql(初期データ作成SQLファイル)を作成する。
                    初期データは以下のSQL文で投入する。
                    <pre><code>
                        INSERT INTO todo (todo_title, finished, created_at ) VALUES ('sample todo 1', false, '2019-09-19 01:01:01' )
                        INSERT INTO todo (todo_title, finished, created_at ) VALUES ('sample todo 2', true, '2019-09-19 02:02:02' )
                        INSERT INTO todo (todo_title, finished, created_at ) VALUES ('sample todo 3', false, '2019-09-19 03:03:03' )                        
                    </code></pre>
                    <h2 id="createtest"><a class="anchor" href="#createtest"></a>5.6.3.2 SpringTestの標準機能を利用したテストの実装</h2>                    
                    @MyBaticTestアノテーションを利用したRepositoryのスライステストのために、TodoRepositoryTestクラスを作成する。
                    <br>
                    (スライステストはテスト対象の動作に必要な最小限のBeanのみをDIしてテストする技法、、たぶん、、、)
                    <br>
                    <table width=500>
                        <tr>
                            <th>項目名</th>
                            <th>設定値</th>
                        </tr>
                        <tr>
                            <td>ソースフォルダ</td>
                            <td>turorial/src/test/java</td>
                        </tr>
                        <tr>
                           <td>パッケージ</td>
                           <td>com.example.tutorial.todo</td>
                       </tr>
                       <tr>
                           <td>名前</td>
                            <td>TodoRepositoryTest</td>
                        </tr>
                    </table>
                    <br>
                    上記で作成したソースに以下を記述
                    <pre><code>
                        package com.example.tutorial.todo;

                        import static org.assertj.core.api.Assertions.assertThat;
                        import static org.assertj.core.api.Assertions.tuple;
                        import java.time.LocalDateTime;
                        import java.time.format.DateTimeFormatter;
                        import java.util.Collection;
                        import org.junit.jupiter.api.DisplayName;
                        import org.junit.jupiter.api.Test;
                        import org.mybatis.spring.boot.test.autoconfigure.MybatisTest;
                        import org.springframework.beans.factory.annotation.Autowired;
                        import org.springframework.jdbc.core.BeanPropertyRowMapper;
                        import org.springframework.jdbc.core.RowMapper;
                        import org.springframework.jdbc.core.namedparam.EmptySqlParameterSource;
                        import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
                        import org.springframework.jdbc.core.namedparam.NamedParameterJdbcOperations;
                        import org.springframework.jdbc.core.namedparam.SqlParameterSource;
                        
                        @MybatisTest // (1)
                        public class TodoRepositoryTest {
                        
                            private static final DateTimeFormatter DATETIME_FORMAT = DateTimeFormatter.ofPattern("uuuu/MM/dd HH:mm:ss");
                        
                            @Autowired
                            private TodoRepository todoRepository; // (2)
                        
                            @Autowired
                            NamedParameterJdbcOperations jdbcOperations; // (3)
                        
                            @Test
                            @DisplayName("全Todoが取得できることを確認する(Repository)")
                            void testFindAll() {
                                // run
                                Collection<Todo> actualTodos = todoRepository.findAll();
                        
                                // check
                                assertThat(actualTodos)
                                    .extracting(Todo::getTodoId, Todo::getTodoTitle, Todo::isFinished, Todo::getCreatedAt)
                                    .contains(tuple(1L, "sample todo 1", false, LocalDateTime.parse("2019/09/19 01:01:01", DATETIME_FORMAT)),
                                            tuple(2L, "sample todo 2", true, LocalDateTime.parse("2019/09/19 02:02:02", DATETIME_FORMAT)),
                                            tuple(3L, "sample todo 3", false, LocalDateTime.parse("2019/09/19 03:03:03", DATETIME_FORMAT)));
                            }
                        
                            @Test
                            @DisplayName("todoIdに対応するTodoが取得できることを確認する(Repository)")
                            void testFindById() {
                                // run
                                Todo actualTodo = todoRepository.findById(1L).get();
                        
                                // check
                                assertThat(actualTodo)
                                    .extracting(Todo::getTodoId, Todo::getTodoTitle, Todo::isFinished, Todo::getCreatedAt)
                                    .contains(1L, "sample todo 1", false, LocalDateTime.parse("2019/09/19 01:01:01", DATETIME_FORMAT));
                            }
                        
                            @Test
                            @DisplayName("新たなTodoが作成できることを確認する(Repository)")
                            void testCreate() {
                                // setup
                                Todo actualTodo = new Todo(null, "sample todo 4", false, LocalDateTime.parse("2019/09/19 04:04:04", DATETIME_FORMAT));
                        
                                // run
                                todoRepository.create(actualTodo);
                        
                                // check
                                Todo todo = getLastTodo();
                                assertThat(actualTodo)
                                    .isEqualToIgnoringGivenFields(todo, "todoId")
                                    .hasNoNullFieldsOrProperties();
                            }
                        
                            @Test
                            @DisplayName("finishedをfalseからtrueに変更できることを確認する(Repository)")
                            void testUpdateById() {
                                // setup
                                Todo todo = getTodo(1L);
                        
                                // run
                                long count = todoRepository.updateById(1L);
                                Todo updated = getTodo(1L);
                        
                                // check
                                assertThat(count).isEqualTo(1L);
                                assertThat(updated)
                                    .isEqualToIgnoringGivenFields(todo, "finished")
                                    .hasFieldOrPropertyWithValue("finished", true);
                            }
                        
                            @Test
                            @DisplayName("todoId=1が削除できていることを確認する(Repository)")
                            void testDeleteById() {
                                // run
                                long count = todoRepository.deleteById(1L);
                        
                                // check
                                assertThat(count).isEqualTo(1);
                            }
                        
                            @Test
                            @DisplayName("未完了 or 完了済のTodoの件数を取得できることを確認する(Repository)")
                            void testCountByFinished() {
                                // run
                                long unfinishedCount = todoRepository.countByFinished(false);
                                long finishedCount = todoRepository.countByFinished(true);
                        
                                // check
                                assertThat(unfinishedCount).isEqualTo(2);
                                assertThat(finishedCount).isEqualTo(1);
                            }
                        
                            private Todo getLastTodo() {
                                String sql = "SELECT * FROM todo ORDER BY todo_id DESC LIMIT 1";
                                SqlParameterSource paramSource = new EmptySqlParameterSource();
                                RowMapper<Todo> rowMapper = new BeanPropertyRowMapper<>(Todo.class);
                                return jdbcOperations.queryForObject(sql, paramSource, rowMapper);
                            }
                        
                            private Todo getTodo(Long todoId) {
                                String sql = "SELECT * FROM todo WHERE todo_id=:todoId";
                                SqlParameterSource paramSource = new MapSqlParameterSource().addValue("todoId", todoId);
                                RowMapper<Todo> rowMapper = new BeanPropertyRowMapper<>(Todo.class);
                                return jdbcOperations.queryForObject(sql, paramSource, rowMapper);
                            }
                        
                        }
                    </code></pre>
                    上記コードのポイントを以下に記述
                    (スライステストはテスト対象の動作に必要な最小限のBeanのみをDIしてテストする技法、、たぶん、、、)
                    <br>
                    <table width=500>
                        <tr>
                            <th>ポイント</th>
                            <th>メモ</th>
                        </tr>
                        <tr>
                            <td>@MybatisTest</td>
                            <td>このアノテーションをつけることでBean登録される対象がMyBatisが利用するものに限定される。内部的には@Transactionが付与されており、テストコードを一つのトランザクション内で処理し、完了後はロールバックする。</td>
                        </tr>
                        <tr>
                           <td>@Autowired
                            　　<br>    
                               private TodoRepository todoRepository</td>
                           <td>todoRepositoryインターフェースをDIしている。以降でインターフェースを利用したテストコードを記述し、テストを実施している。</td>
                       </tr>
                       <tr>
                           <td>    @Autowired <br>
                            NamedParameterJdbcOperations jdbcOperations; </td>
                            <td>NamedParameterJDBCOperationsインターフェースをDIしている。MyBaticが用意したデータソースとデータベースの間をつなぐのがJDBCの理解。
                                <br>
                                今回はこのインターフェースのqueryForObjectを利用して、sql文、sql文実行パラメータ、戻りの型で実行し、テストしている。
                                詳細は<a href="https://spring.pleiades.io/spring-framework/docs/current/javadoc-api/org/springframework/jdbc/core/namedparam/NamedParameterJdbcOperations.html">こちら</a>
                                <br>
                                疑問。結局SQL文の発行を独自に定義してしまっているがこれでテストになっているの？
                                <br>
                                →独自SQLは答え合わせ用の結果を取得するためのもの。例えば66行目-69行目でtodoRepository.create(actualTodo)を呼び出した後に独自SQLで結果を取り出してNullがないかを見ている。
                            </td>
                        </tr>
                        <tr>
                            <td>@Test</td>
                            <td>テストの実行単位</td>
                        </tr>
                        <tr>
                            <td>@DisplayName</td>
                            <td>テストの表示名。このあとJUnitで実行したらイメージが分かるはず。</td>
                        </tr>
                    </table>
                    <h2 id="dotest"><a class="anchor" href="#dotest"></a>5.6.3.3 TodoRepositoryテストの実行</h2>
                    TodoRepositoryTest.javaを右クリックし、[Run AS]→[JUnit Test]を選択し、テストを実行する。
                    <br>
                    実行するも以下のコンソールエラーとともに、テストケースが1件も実行されず、異常終了した。(6件の件数は良い込めているが。。)
                    <pre><core>
                        22:18:00.349 [main] DEBUG org.springframework.test.context.BootstrapUtils - Instantiating CacheAwareContextLoaderDelegate from class [org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate]
                        22:18:00.369 [main] DEBUG org.springframework.test.context.BootstrapUtils - Instantiating BootstrapContext using constructor [public org.springframework.test.context.support.DefaultBootstrapContext(java.lang.Class,org.springframework.test.context.CacheAwareContextLoaderDelegate)]
                        22:18:00.443 [main] DEBUG org.springframework.test.context.BootstrapUtils - Instantiating TestContextBootstrapper for test class [com.example.tutorial.todo.TodoRepositoryTest] from class [org.mybatis.spring.boot.test.autoconfigure.MybatisTestContextBootstrapper]
                        22:18:00.467 [main] INFO org.mybatis.spring.boot.test.autoconfigure.MybatisTestContextBootstrapper - Neither @ContextConfiguration nor @ContextHierarchy found for test class [com.example.tutorial.todo.TodoRepositoryTest], using SpringBootContextLoader
                        22:18:00.474 [main] DEBUG org.springframework.test.context.support.AbstractContextLoader - Did not detect default resource location for test class [com.example.tutorial.todo.TodoRepositoryTest]: class path resource [com/example/tutorial/todo/TodoRepositoryTest-context.xml] does not exist
                        22:18:00.475 [main] DEBUG org.springframework.test.context.support.AbstractContextLoader - Did not detect default resource location for test class [com.example.tutorial.todo.TodoRepositoryTest]: class path resource [com/example/tutorial/todo/TodoRepositoryTestContext.groovy] does not exist
                        22:18:00.476 [main] INFO org.springframework.test.context.support.AbstractContextLoader - Could not detect default resource locations for test class [com.example.tutorial.todo.TodoRepositoryTest]: no resource found for suffixes {-context.xml, Context.groovy}.
                        22:18:00.478 [main] INFO org.springframework.test.context.support.AnnotationConfigContextLoaderUtils - Could not detect default configuration classes for test class [com.example.tutorial.todo.TodoRepositoryTest]: TodoRepositoryTest does not declare any static, non-private, non-final, nested classes annotated with @Configuration.
                        22:18:00.607 [main] DEBUG org.springframework.test.context.support.ActiveProfilesUtils - Could not find an 'annotation declaring class' for annotation type [org.springframework.test.context.ActiveProfiles] and class [com.example.tutorial.todo.TodoRepositoryTest]                        
                    </core></pre>
                    クラスパスが見つからないエラーっぽいのでとりあえず、Mavenをリフレッシュしてみる。→解決せず・
                    JUnitタブにスタックトレースがあったので確認してみる。
                    <pre><code>
                        java.lang.IllegalStateException: Unable to find a @SpringBootConfiguration, you need to use @ContextConfiguration or @SpringBootTest(classes=...) with your test
                        at org.springframework.util.Assert.state(Assert.java:76)
                        at org.springframework.boot.test.context.SpringBootTestContextBootstrapper.getOrFindConfigurationClasses(SpringBootTestContextBootstrapper.java:236)
                        at org.springframework.boot.test.context.SpringBootTestContextBootstrapper.processMergedContextConfiguration(SpringBootTestContextBootstrapper.java:152)
                        at org.springframework.test.context.support.AbstractTestContextBootstrapper.buildMergedContextConfiguration(AbstractTestContextBootstrapper.java:392)
                        at org.springframework.test.context.support.AbstractTestContextBootstrapper.buildDefaultMergedContextConfiguration(AbstractTestContextBootstrapper.java:309)
                        at org.springframework.test.context.support.AbstractTestContextBootstrapper.buildMergedContextConfiguration(AbstractTestContextBootstrapper.java:262)
                        at org.springframework.test.context.support.AbstractTestContextBootstrapper.buildTestContext(AbstractTestContextBootstrapper.java:107)
                        at org.springframework.boot.test.context.SpringBootTestContextBootstrapper.buildTestContext(SpringBootTestContextBootstrapper.java:102)
                        at org.springframework.test.context.TestContextManager.<init>(TestContextManager.java:137)
                        at org.springframework.test.context.TestContextManager.<init>(TestContextManager.java:122)
                        at org.junit.jupiter.engine.execution.ExtensionValuesStore.lambda$getOrComputeIfAbsent$4(ExtensionValuesStore.java:86)
                        at org.junit.jupiter.engine.execution.ExtensionValuesStore$MemoizingSupplier.computeValue(ExtensionValuesStore.java:223)
                        at org.junit.jupiter.engine.execution.ExtensionValuesStore$MemoizingSupplier.get(ExtensionValuesStore.java:211)
                        at org.junit.jupiter.engine.execution.ExtensionValuesStore$StoredValue.evaluate(ExtensionValuesStore.java:191)
                        at org.junit.jupiter.engine.execution.ExtensionValuesStore$StoredValue.access$100(ExtensionValuesStore.java:171)
                        at org.junit.jupiter.engine.execution.ExtensionValuesStore.getOrComputeIfAbsent(ExtensionValuesStore.java:89)
                        at org.junit.jupiter.engine.execution.ExtensionValuesStore.getOrComputeIfAbsent(ExtensionValuesStore.java:93)
                        at org.junit.jupiter.engine.execution.NamespaceAwareStore.getOrComputeIfAbsent(NamespaceAwareStore.java:61)
                        at org.springframework.test.context.junit.jupiter.SpringExtension.getTestContextManager(SpringExtension.java:294)
                        at org.springframework.test.context.junit.jupiter.SpringExtension.beforeAll(SpringExtension.java:113)
                        at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.lambda$invokeBeforeAllCallbacks$8(ClassBasedTestDescriptor.java:368)
                        at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
                        at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.invokeBeforeAllCallbacks(ClassBasedTestDescriptor.java:368)
                        at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.before(ClassBasedTestDescriptor.java:192)
                        at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.before(ClassBasedTestDescriptor.java:78)
                        at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:136)
                        at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
                        at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:129)
                        at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)
                        at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:127)
                        at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
                        at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:126)
                        at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:84)
                        at java.base/java.util.ArrayList.forEach(ArrayList.java:1511)
                        at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38)
                        at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:143)
                        at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
                        at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:129)
                        at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137)
                        at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:127)
                        at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
                        at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:126)
                        at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:84)
                        at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:32)
                        at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57)
                        at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:51)
                        at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:108)
                        at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:88)
                        at org.junit.platform.launcher.core.EngineExecutionOrchestrator.lambda$execute$0(EngineExecutionOrchestrator.java:54)
                        at org.junit.platform.launcher.core.EngineExecutionOrchestrator.withInterceptedStreams(EngineExecutionOrchestrator.java:67)
                        at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:52)
                        at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:96)
                        at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:84)
                        at org.eclipse.jdt.internal.junit5.runner.JUnit5TestReference.run(JUnit5TestReference.java:98)
                        at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:40)
                        at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:529)
                        at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:756)
                        at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:452)
                        at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:210)                    
                    </code></pre>
                    @ContextConfigurationか@SpringBootTestの指定が必要と怒られている。@MyBatisTestで良いとチュートリアルには記載があるが。。。
                    <br>
                    親パッケージ作成時にtororial.example.comとしたせいでSpringBootの起動クラス(TurorialApplication)が別パッケージに存在し、テストコードが認識できずにおこったエラーだった。TurorialApplicationを同じパッケージに移動させたらどりあえずテストコードを実行できた
                    <br>
                    次は全テストがNGとなった。。。テーブルTODOが見つからないとのこと。schema.sqlで作ったはずですが。。。
                    調べたが分からず、application.yamlからapplication.propertiesにファイル名を変更し、以下のデータソース設定(記載なしで本来デフォルト設定されるはずのもの)を設定し、テストを再実行したところ、起動時になぜかテーブルがちゃんと作成でき、テストが全て正常終了した。
                    <pre><code>
                        spring.datasource.url=jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=false
                        spring.datasource.username=sa
                        spring.datasource.password=
                        spring.datasource.driver-class-name=org.h2.Driver
                        spring.datasource.initialization-mode=embedded
                    </code></pre>
                </ul>
                <h2 id="createservice"><a class="anchor" href="#createservice"></a>5.7 Serviceの作成</h2>
                Todoリソースの取得、登録、削除、完了を行う業務処理クラスを実装する。
                <ul>
                    <h3 id="createexception"><a class="anchor" href="#createexception"></a>5.7.1 例外処理クラスの作成</h3>
                    BusinessExceptionクラスとResourceNotFoundExceptionクラスを作成する。
                    <li>BusinesExceptionクラスの作成</li>
                    <ul>
                    <table width=500>
                        <tr>
                            <th>項目名</th>
                            <th>設定値</th>
                        </tr>
                        <tr>
                            <td>ソースフォルダ</td>
                            <td>turorial/src/main/java</td>
                        </tr>
                        <tr>
                           <td>パッケージ</td>
                           <td>com.example.tutorial.common.exception</td>
                       </tr>
                       <tr>
                           <td>名前</td>
                            <td>BusinessException</td>
                        </tr>
                        <tr>
                            <td>スーパークラス</td>
                             <td>java.lang.RuntimeException</td>
                         </tr>
                    </table>
                    <br>
                    <pre><code>
                        package com.example.tutorial.common.exception;

                        import org.springframework.http.HttpStatus;
                        import org.springframework.web.bind.annotation.ResponseStatus;
                        
                        @ResponseStatus(code = HttpStatus.CONFLICT)
                        public class BusinessException extends RuntimeException {
                        
                            private static final long serialVersionUID = 1L;
                        
                            public BusinessException(String message) {
                                super(message);
                            }
                        
                            public BusinessException(String message, Throwable cause) {
                                super(message, cause);
                            }
                        
                        }
                    </code></pre>
                    <table width=500>
                        <tr>
                            <th>ポイント</th>
                            <th>メモ</th>
                        </tr>
                        <tr>
                            <td>@ResponseStatus</td>
                            <td>引数を通してクライアントにHTTPステータスコードを返却するためのアノテーション。code = HttpStatus.CONFLICTで、409を返却する。一般的なステータスコード名と紐づいているよう。<a href="https://developer.mozilla.org/ja/docs/Web/HTTP/Status">ステータスコードについてはこちらを参照。</a></td>
                        </tr>
                        <tr>
                            <td>java.lang.RuntimeExceptionを継承</td>
                            <td>RuntimeExceptionはアプリを運用する中で起こる回復不要な例外をキャッチするクラス。<a href="https://programmer-life.work/java/runtime-exception-java">java.lang.RuntimeExceptionについてはこちらを参照。</a><br>
                            super(message)で親クラスであるRuntimeExceptionのコンストラクタをmessageを引数にして呼び出している。<a href="https://docs.oracle.com/javase/jp/8/docs/api/java/lang/RuntimeException.html">java.lang.RuntimeExceptionで実装されているコンストラクタについてはこちらを参照。</a>
                            </td>
                        </tr>
                    </table>
                </ul>
                    <li>ResourceNotFoundExceptionクラス</li>
                    <ul>
                    <table width=500>
                        <tr>
                            <th>項目名</th>
                            <th>設定値</th>
                        </tr>
                        <tr>
                            <td>ソースフォルダ</td>
                            <td>turorial/src/main/java</td>
                        </tr>
                        <tr>
                           <td>パッケージ</td>
                           <td>com.example.tutorial.common.exception</td>
                       </tr>
                       <tr>
                           <td>名前</td>
                            <td>ResourceNotFoundException</td>
                        </tr>
                        <tr>
                            <td>スーパークラス</td>
                             <td>java.lang.RuntimeException</td>
                        </tr>
                    </table>
                    特に留意事項はない。
                </ul>
                <h3 id="createserviceif"><a class="anchor" href="#createserviceif"></a>5.7.2 TodoServiceインターフェースの作成</h3>
                インターフェースを以下の通り作成する。
                <table width=500>
                    <tr>
                        <th>項目名</th>
                        <th>設定値</th>
                    </tr>
                    <tr>
                        <td>ソースフォルダ</td>
                        <td>turorial/src/main/java</td>
                    </tr>
                    <tr>
                       <td>パッケージ</td>
                       <td>com.example.tutorial.todo</td>
                   </tr>
                   <tr>
                       <td>名前</td>
                        <td>TodoService</td>
                    </tr>
                </table>
                <pre><code>
                    package com.example.tutorial.todo;

                    import java.util.Collection;
                    
                    public interface TodoService {
                    
                        Todo findOne(Long todoId);
                    
                        Collection<Todo> findAll();
                    
                        Todo create(Todo todo);
                    
                        Todo finish(Long todoId);
                    
                        void delete(Long todoId);
                    }
                </code></pre>
                <table width=500>
                    <tr>
                        <th>ポイント</th>
                        <th>メモ</th>
                    </tr>
                    <tr>
                        <td>記述するメソッドについて</td>
                        <td>後続で実装する業務処理である、検索、全件検索、作成、完了、削除のインターフェースを作成する。具体的なロジックの記載はimpl側に記載するので不要。なお、サービスをコントローラから呼び出す際はインターフェースを呼び出すことで、実装の改修に強いアプリの作りにするのが一般的。なぜ、実装側ではなくインターフェースを呼び出して動くのかは疑問。</td>
                    </tr>
                </table>
                <h3 id="createserviceimpl"><a class="anchor" href="#createserviceimpl"></a>5.7.3 TodoServiceImplクラスの作成</h3>
                クラスを以下の通り作成する。
                <table width=500>
                    <tr>
                        <th>項目名</th>
                        <th>設定値</th>
                    </tr>
                    <tr>
                        <td>ソースフォルダ</td>
                        <td>turorial/src/main/java</td>
                    </tr>
                    <tr>
                       <td>パッケージ</td>
                       <td>com.example.tutorial.todo</td>
                   </tr>
                   <tr>
                       <td>名前</td>
                        <td>TodoServiceImpl</td>
                    </tr>
                    <tr>
                        <td>インターフェース</td>
                         <td>com.example.tutorial.TodoService</td>
                     </tr>
                </table>
                <pre><code>
                    package com.example.tutorial.todo;

                    import java.time.LocalDateTime;
                    import java.util.Collection;
                    import org.springframework.beans.factory.annotation.Autowired;
                    import org.springframework.stereotype.Service;
                    import org.springframework.transaction.annotation.Transactional;
                    import com.example.tutorial.common.exception.BusinessException;
                    import com.example.tutorial.common.exception.ResourceNotFoundException;
                    
                    @Service // (1)
                    @Transactional // (2)
                    public class TodoServiceImpl implements TodoService {
                    
                        private static final long MAX_UNFINISHED_COUNT = 5;
                    
                        @Autowired // (3)
                        TodoRepository todoRepository;
                    
                        @Override
                        public Todo findOne(Long todoId) {
                            return todoRepository.findById(todoId).orElseThrow(() -> new ResourceNotFoundException(
                                    "The requested Todo is not found. (id=" + todoId + ")"));
                        }
                    
                        @Override
                        public Collection<Todo> findAll() {
                            return todoRepository.findAll();
                        }
                    
                        @Override
                        public Todo create(Todo todo) {
                            long unfinishedCount = todoRepository.countByFinished(false);
                            if (unfinishedCount >= MAX_UNFINISHED_COUNT) {
                                throw new BusinessException(
                                        "The count of un-finished Todo must not be over " + MAX_UNFINISHED_COUNT + ".");
                            }
                    
                            LocalDateTime createdAt = LocalDateTime.now();
                            todo.setCreatedAt(createdAt);
                            todo.setFinished(false);
                    
                            todoRepository.create(todo);
                            return todo;
                        }
                    
                        @Override
                        public Todo finish(Long todoId) {
                            Todo todo = findOne(todoId);
                            if (todo.isFinished()) {
                                throw new BusinessException(
                                        "The requested Todo is already finished. (id=" + todoId + ")");
                            }
                            todo.setFinished(true);
                            todoRepository.updateById(todoId);
                            return todo;
                        }
                    
                        @Override
                        public void delete(Long todoId) {
                            findOne(todoId);
                            todoRepository.deleteById(todoId);
                        }
                    
                    }                </code></pre>
                <table width=500>
                    <tr>
                        <th>ポイント</th>
                        <th>メモ</th>
                    </tr>
                    <tr>
                        <td>@Service</td>
                        <td>サービスとしてBean登録するための記述。おそらくこの記述でSpringBootフレームワーク上でControllerからのマッピング処理などが可能になる理解</td>
                    </tr>
                    <tr>
                        <td>@Transactional</td>
                        <td>トランザクションを実行する宣言。ここの設定はいろいろあるが、割愛。</td>
                    </tr>
                    <tr>
                        <td>他インスタンスとのデータのやり取り。</td>
                        <td>Todoオブジェクトにデータを詰めて、他のオブジェクト(Repositoryなど)とデータをやり取りしている。Todo.javaはオブジェクト間のデータやりとりの形式を定義したリポジトリでTodoResourceクラスがクライアントとのデータのやり取りの形式を定義したクラスと理解。</td>
                    </tr>
                </table>
                <h3 id="testservice"><a class="anchor" href="#testeservice"></a>5.7.4 Serviceの単体テスト</h3>
                TodoServiceの単体テストを実施する。依存クラスがまだ完成していない場合に依存クラスのモック化を行う。<a href="https://qiita.com/Fudeko/items/301f8a80963dfcaafb80">モック化についてはこちらを参照。</a>
                <br>
                今回は作成済みではあるが練習のためにtodoRepsitoryをモック化するテストコードを記述する。これにより、todoRepositoryのロジックを利用せず、todoRepositoryのリターンを固定値として扱うことが出来る。
                <table width=500>
                    <tr>
                        <th>項目名</th>
                        <th>設定値</th>
                    </tr>
                    <tr>
                        <td>ソースフォルダ</td>
                        <td>turorial/src/test/java</td>
                    </tr>
                    <tr>
                       <td>パッケージ</td>
                       <td>com.example.tutorial.todo</td>
                   </tr>
                   <tr>
                       <td>名前</td>
                        <td>TodoServiceTest</td>
                    </tr>
                </table>
                <pre><code>
                    package com.example.tutorial.todo;

                    import static org.assertj.core.api.Assertions.assertThat;
                    import static org.mockito.BDDMockito.given;
                    import static org.mockito.BDDMockito.then;
                    import static org.mockito.BDDMockito.willDoNothing;
                    import static org.mockito.Mockito.times;
                    import java.time.LocalDateTime;
                    import java.time.format.DateTimeFormatter;
                    import java.util.Arrays;
                    import java.util.Collection;
                    import java.util.Objects;
                    import java.util.Optional;
                    import org.junit.jupiter.api.DisplayName;
                    import org.junit.jupiter.api.Test;
                    import org.mockito.ArgumentMatchers;
                    import org.springframework.beans.factory.annotation.Autowired;
                    import org.springframework.boot.test.context.SpringBootTest;
                    import org.springframework.boot.test.mock.mockito.MockBean;
                    
                    @SpringBootTest(classes = TodoServiceImpl.class) // (1)
                    public class TodoServiceTest {
                    
                        private static final DateTimeFormatter DATETIME_FORMAT = DateTimeFormatter.ofPattern("uuuu/MM/dd HH:mm:ss");
                    
                        @Autowired
                        private TodoService todoService; // (2)
                    
                        @MockBean
                        private TodoRepository todoRepository; // (3)
                    
                        @Test
                        @DisplayName("全Todoが取得できることを確認する(service)")
                        void testFindAll() {
                            // setup
                            Todo expectTodo1 = new Todo(1L, "sample todo 1", false, LocalDateTime.parse("2019/09/19 01:01:01", DATETIME_FORMAT));
                            Todo expectTodo2 = new Todo(2L, "sample todo 2", true, LocalDateTime.parse("2019/09/19 02:02:02", DATETIME_FORMAT));
                            Todo expectTodo3 = new Todo(3L, "sample todo 3", false, LocalDateTime.parse("2019/09/19 03:03:03", DATETIME_FORMAT));
                    
                            // setup mocks
                            given(todoRepository.findAll()).willReturn(Arrays.asList(expectTodo1, expectTodo2, expectTodo3));
                    
                            // run
                            Collection<Todo> actualTodos = todoService.findAll();
                    
                            // check
                            then(todoRepository).should(times(1)).findAll();
                            assertThat(actualTodos).usingFieldByFieldElementComparator().containsExactly(expectTodo1, expectTodo2, expectTodo3);
                        }
                    
                        @Test
                        @DisplayName("todoIdに対応するTodoが取得できることを確認する(Service)")
                        void testFindOne() {
                            // setup
                            Todo expectTodo = new Todo(1L, "sample todo 1", false, LocalDateTime.parse("2019/09/19 01:01:01", DATETIME_FORMAT));
                    
                            // setup mocks
                            given(todoRepository.findById(1L)).willReturn(Optional.of(expectTodo));
                    
                            // run
                            Todo actualTodo = todoService.findOne(1L);
                    
                            // check
                            then(todoRepository).should(times(1)).findById(ArgumentMatchers.longThat(arg -> arg == actualTodo.getTodoId()));
                            assertThat(actualTodo).isEqualToComparingFieldByField(expectTodo);
                        }
                    
                        @Test
                        @DisplayName("新たなTodoが作成できることを確認する(service)")
                        void testCreate() {
                            // setup
                            Todo expectTodo = new Todo(null, "sample todo 4", false, null);
                    
                            // setup mocks
                            willDoNothing().given(todoRepository).create(expectTodo);
                    
                            // run
                            todoService.create(expectTodo);
                    
                            // check
                            then(todoRepository).should(times(1)).create(
                                    ArgumentMatchers.<Todo>argThat(
                                            arg -> expectTodo.getTodoTitle().equals(arg.getTodoTitle())
                                            && !arg.isFinished()
                                            && Objects.nonNull(arg.getCreatedAt())
                                            )
                                    );
                        }
                    
                        @Test
                        @DisplayName("todoId=1のfinishedがtrueになることを確認する(service)")
                        void testFinish() {
                            // setup
                            Todo expectTodo = new Todo(1L, "sample todo 1", false, LocalDateTime.parse("2019/09/19 01:01:01", DATETIME_FORMAT));
                    
                            // setup mocks
                            given(todoRepository.findById(1L)).willReturn(Optional.of(expectTodo));
                            given(todoRepository.updateById(1L)).willReturn(1L);
                    
                            // run
                            todoService.finish(1L);
                    
                            // check
                            then(todoRepository).should(times(1)).findById(ArgumentMatchers.longThat(arg -> arg == expectTodo.getTodoId()));
                            then(todoRepository).should(times(1)).updateById(ArgumentMatchers.longThat(arg -> arg == 1L));
                        }
                    
                        @Test
                        @DisplayName("todoId=1がDeleteによって削除されることを確認する(service)")
                        void testDelete() {
                            // setup
                            Todo expectTodo = new Todo(1L, "sample todo 1", false, LocalDateTime.parse("2019/09/19 01:01:01", DATETIME_FORMAT));
                    
                            // setup mocks
                            given(todoRepository.findById(1L)).willReturn(Optional.of(expectTodo));
                            given(todoRepository.deleteById(1L)).willReturn(1L);
                    
                            // run
                            todoService.delete(1L);
                    
                            // check
                            then(todoRepository).should(times(1)).findById(ArgumentMatchers.longThat(arg -> arg == expectTodo.getTodoId()));
                            then(todoRepository).should(times(1)).deleteById(ArgumentMatchers.longThat(arg -> arg == 1L));
                        }
                    }
                </code></pre>
                <table width=500>
                    <tr>
                        <th>ポイント</th>
                        <th>メモ</th>
                    </tr>
                    <tr>
                        <td>@SpringBootTest(classes = TodoServiceImpl.class)</td>
                        <td>SpringTestの実行対象のクラスを定義する。Repositoryのテストでは@MyBatisTestを指定したが、これはMyBatic専用のアノテーション。通常は@SpringBootTestを指定する。</td>
                    </tr>
                    <tr>
                        <td>@MockBean</td>
                        <td>モック化する依存クラスを指定する。今回はtodoRepositoryを指定。</td>
                    </tr>
                    <tr>
                        <td>given(todoRepository.findAll()).willReturn(Arrays.asList(expectTodo1, expectTodo2, expectTodo3));</td>
                        <td>モックの実装。todoRepository.findAll()が返却するであろう値をArrays.asList(expectTodo1, expectTodo2, expectTodo3)に固定化している。(実際のtodoRepositoryのロジックを利用しない。)</td>
                    </tr>
                </table>
                <h3 id="doservicetest"><a class="anchor" href="#doservicetest"></a>5.7.5 TodoServiceのテスト実行</h3>
                TodoService.javaを右クリックして、JUnitを実行する。オールグリーンになれば正常終了。(エラーは出ず、、、)
                </ul>
                <h2 id="createctl"><a class="anchor" href="#createctl"></a>6. Controllerクラスの作成</h2>
                クラスを以下の通り作成する。
                <table width=500>
                    <tr>
                        <th>項目名</th>
                        <th>設定値</th>
                    </tr>
                    <tr>
                        <td>ソースフォルダ</td>
                        <td>turorial/src/main/java</td>
                    </tr>
                    <tr>
                       <td>パッケージ</td>
                       <td>com.example.tutorial.todo</td>
                   </tr>
                   <tr>
                       <td>名前</td>
                        <td>TodoContoroller</td>
                    </tr>
                </table>
                <pre><code>
                    package com.example.tutorial.todo;

                    import java.util.Collection;
                    import java.util.List;
                    import java.util.stream.Collectors;
                    import org.springframework.http.HttpStatus;
                    import org.springframework.validation.annotation.Validated;
                    import org.springframework.beans.factory.annotation.Autowired;
                    import org.springframework.web.bind.annotation.DeleteMapping;
                    import org.springframework.web.bind.annotation.GetMapping;
                    import org.springframework.web.bind.annotation.PathVariable;
                    import org.springframework.web.bind.annotation.PostMapping;
                    import org.springframework.web.bind.annotation.PutMapping;
                    import org.springframework.web.bind.annotation.RequestBody;
                    import org.springframework.web.bind.annotation.RequestMapping;
                    import org.springframework.web.bind.annotation.ResponseStatus;
                    import org.springframework.web.bind.annotation.RestController;
                    import com.github.dozermapper.core.Mapper;
                    
                    @RestController // (1)
                    @RequestMapping("todos") // (2)
                    public class TodoController {
                    
                        @Autowired // (3)
                        TodoService todoService;
                    
                        @Autowired // (4)
                        Mapper beanMapper;
                    
                        @GetMapping
                        public List<TodoResource> getTodos() {
                            Collection<Todo> todos = todoService.findAll();
                            return todos.stream().map(todo -> beanMapper.map(todo, TodoResource.class))
                                    .collect(Collectors.toList());
                        }
                    
                        @GetMapping("{todoId}")
                        public TodoResource getTodo(@PathVariable("todoId") Long todoId) {
                            Todo todo = todoService.findOne(todoId);
                            return beanMapper.map(todo, TodoResource.class);
                        }
                    
                        @PostMapping
                        @ResponseStatus(HttpStatus.CREATED)
                        public TodoResource postTodo(@RequestBody @Validated TodoResource todoResource) {
                            Todo createdTodo = todoService.create(beanMapper.map(todoResource, Todo.class));
                            return beanMapper.map(createdTodo, TodoResource.class);
                        }
                    
                        @PutMapping("{todoId}")
                        public TodoResource putTodo(@PathVariable("todoId") Long todoId) {
                            Todo finishedTodo = todoService.finish(todoId);
                            return beanMapper.map(finishedTodo, TodoResource.class);
                        }
                    
                        @DeleteMapping("{todoId}")
                        @ResponseStatus(HttpStatus.NO_CONTENT)
                        public void deleteTodo(@PathVariable("todoId") Long todoId) {
                            todoService.delete(todoId);
                        }
                    
                    }
                </code></pre>
                <table>
                <tr>
                    <th>ポイント</th>
                    <th>メモ</th>
                </tr>
                <tr>
                    <td>@RestController</td>
                    <td>RestAPI用のコントローラアノテーション。これにより、クライアントからのアクセスを受付け、レスポンスボディにはJSONを埋め込むようになる。</td>
                </tr>
                <tr>
                    <td>beanMapper.map(todo, TodoResource.class)</td>
                    <td>各処理ではサービスから受け取ったtodoオブジェクトを取り扱うが、このままではクライアントに返却出来ないため、beanMapperにより、TodoResource.classに変換している。具体的には、todoオブジェクトのプロパティ名とTodoResource.classのプロパティ名をマッピングし、コピーしている。</td>
                </tr>
                <tr>
                    <td>@RequestMapping("todos") </td>
                    <td>リクエストURLをこのコントローラにマッピングしている。以降でメソッドごとのマッピングが定義され、中には引数が入っているものがあるが、これもURLであり、todos/todoIdで定義される。</td>
                </tr>
            </table>
                Contorollerのテストのやり方はTodoServicとほぼ同じ(今回はTodoServiceをモック化)。以下に概要を記載する。
                <ol>
                    <li>TodoControllerTestを作成する。</li>
                    <li>テストコードは以下の通り。
                        <pre><code>
                            package com.example.tutorial.todo;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.BDDMockito.given;
import static org.mockito.BDDMockito.then;
import static org.mockito.Mockito.times;
import java.net.URI;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Arrays;
import java.util.Collection;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentMatchers;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.context.SpringBootTest.WebEnvironment;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.boot.test.web.client.TestRestTemplate;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpMethod;
import org.springframework.http.HttpStatus;
import org.springframework.http.RequestEntity;
import org.springframework.http.ResponseEntity;
import com.github.dozermapper.core.Mapper;

@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT) // (1)
public class TodoControllerTest {

    private static final DateTimeFormatter DATETIME_FORMAT = DateTimeFormatter.ofPattern("uuuu/MM/dd HH:mm:ss");

    @Autowired // (2)
    private TestRestTemplate testRestTemplate;

    @Autowired
    private Mapper beanMapper;

    @MockBean // (3)
    private TodoService todoService;

    @Test
    @DisplayName("GET Todosが正常に動作することを確認する(Controller)")
    void testGetTodos() {
        // setup
        Todo expectTodo1 = new Todo(1L, "sample todo 1", false, LocalDateTime.parse("2019/09/19 01:01:01", DATETIME_FORMAT));
        Todo expectTodo2 = new Todo(2L, "sample todo 2", true, LocalDateTime.parse("2019/09/19 02:02:02", DATETIME_FORMAT));
        Collection<Todo> expectTodos = Arrays.asList(expectTodo1, expectTodo2);
        TodoResource[] expectTodoResources = expectTodos.stream()
                .map(todo -> beanMapper.map(todo, TodoResource.class)).toArray(TodoResource[]::new);

        // setup mocks
        given(todoService.findAll()).willReturn(expectTodos);

        // run
        ResponseEntity<TodoResource[]> actualResponseEntity =
                testRestTemplate.getForEntity("/todos", TodoResource[].class);

        // check
        then(todoService).should(times(1)).findAll();
        assertThat(actualResponseEntity.getBody()).usingFieldByFieldElementComparator().containsExactly(expectTodoResources[0], expectTodoResources[1]);
        assertThat(actualResponseEntity.getStatusCode()).isEqualTo(HttpStatus.OK);
    }

    @Test
    @DisplayName("GET Todoが正常に動作することを確認する(Controller)")
    void testGetTodo(){
        // setup
        Todo expectTodo = new Todo(1L, "sample todo 1", false, LocalDateTime.parse("2019/09/19 01:01:01", DATETIME_FORMAT));
        TodoResource expectTodoResource = beanMapper.map(expectTodo, TodoResource.class);

        // setup mocks
        given(this.todoService.findOne(1L)).willReturn(expectTodo);

        // run
        ResponseEntity<TodoResource> actualResponseEntity =
                testRestTemplate.getForEntity("/todos/1", TodoResource.class);

        // check
        then(todoService).should(times(1)).findOne(ArgumentMatchers.longThat(arg -> arg == expectTodo.getTodoId()));
        assertThat(actualResponseEntity.getBody()).isEqualToComparingFieldByField(expectTodoResource);
        assertThat(actualResponseEntity.getStatusCode()).isEqualTo(HttpStatus.OK);
    }

    @Test
    @DisplayName("POST Todoが正常に動作することを確認する(Controller)")
    void testPostTodo() {
        // setup
        TodoResource inputTodoResource = new TodoResource();
        inputTodoResource.setTodoTitle("sample todo 4");
        Todo inputTodo = beanMapper.map(inputTodoResource, Todo.class);
        Todo expectTodo = new Todo(4L, "sample todo 4", false, LocalDateTime.parse("2019/09/19 04:04:04", DATETIME_FORMAT));
        TodoResource expectTodoResource = beanMapper.map(expectTodo, TodoResource.class);

        // setup mocks
        given(this.todoService.create(any(Todo.class))).willReturn(expectTodo);

        // run
        ResponseEntity<TodoResource> actualResponseEntity =
                testRestTemplate.postForEntity("/todos", inputTodoResource, TodoResource.class);

        // check
        then(todoService).should(times(1)).create(ArgumentMatchers.<Todo>argThat(arg -> inputTodo.getTodoTitle().equals(arg.getTodoTitle())));
        assertThat(actualResponseEntity.getBody()).isEqualToComparingFieldByField(expectTodoResource);
        assertThat(actualResponseEntity.getStatusCode()).isEqualTo(HttpStatus.CREATED);
    }

    @Test
    @DisplayName("PUT Todoが正常に動作することを確認する(Controller)")
    void testPutTodo() {
        // setup
        Todo expectTodo = new Todo(1L, "sample todo 1", true, LocalDateTime.parse("2019/09/19 01:01:01", DATETIME_FORMAT));
        TodoResource expectTodoResource = beanMapper.map(expectTodo, TodoResource.class);

        // setup mocks
        given(this.todoService.finish(1L)).willReturn(expectTodo);

        // run
        RequestEntity<String> actualRequestEntity =
                RequestEntity.put(URI.create("/todos/1")).body("");
        ResponseEntity<TodoResource> actualResponseEntity =
                testRestTemplate.exchange(actualRequestEntity, TodoResource.class);

        // check
        then(todoService).should(times(1)).finish(ArgumentMatchers.longThat(arg -> arg == expectTodo.getTodoId()));
        assertThat(actualResponseEntity.getBody()).isEqualToComparingFieldByField(expectTodoResource);
        assertThat(actualResponseEntity.getStatusCode()).isEqualTo(HttpStatus.OK);
    }

    @Test
    @DisplayName("DELETE Todoが正常に動作することを確認する(Controller)")
    void testDeleteTodo() {
        // run
        ResponseEntity<String> actualResponseEntity =
                testRestTemplate.exchange("/todos/1", HttpMethod.DELETE, HttpEntity.EMPTY, String.class);

        // check
        then(todoService).should(times(1)).delete(ArgumentMatchers.longThat(arg -> arg == 1L));
        assertThat(actualResponseEntity.getBody()).isNull();
        assertThat(actualResponseEntity.getStatusCode()).isEqualTo(HttpStatus.NO_CONTENT);
    }

}
                        </code></pre>
                    </li>
                </ol>
                <table>
                    <tr>
                        <th>ポイント</th>
                        <th>メモ</th>
                    </tr>
                    <tr>
                        <td>アロー関数</td>
                        <td>todo -> beanMapper.map(todo, TodoResource.class)).toArray(TodoResource[]::new)の記述はおそらくJavaScriptのアロー関数と同じ記法(Javaではラムダ式というらしい)<br>
                        クラス名::newの記述でコンストラクタを参照している。<a href="https://www.sejuku.net/blog/22592">こちらを参照。</a><br>
                        今回はTodoResourceのコンストラクタを生成し、toArrayの引数に渡すことで、TodoResource.classにマッピングされたexceptTodosコレクション内の要素からTodoResourceオブジェクトで構成されるAllayを生成している。
                        わざわざAllayにしているのはこの後のassertThatで期待結果(expectTodoResources)と実際の結果(actualResponseEntity.getBody())を比較する際にactualResponseEntity.getBody()がtestRestTemplateの仕様でAllayに格納されているからと理解。
                        </td>
                    </tr>
                    <tr>
                        <td>beanMapper.map(todo, TodoResource.class)</td>
                        <td>各処理ではサービスから受け取ったtodoオブジェクトを取り扱うが、このままではクライアントに返却出来ないため、beanMapperにより、TodoResource.classに変換している。具体的には、todoオブジェクトのプロパティ名とTodoResource.classのプロパティ名をマッピングし、コピーしている。</td>
                    </tr>
                    <tr>
                        <td>@RequestMapping("todos") </td>
                        <td>リクエストURLをこのコントローラにマッピングしている。以降でメソッドごとのマッピングが定義され、中には引数が入っているものがあるが、これもURLであり、todos/todoIdで定義される。</td>
                    </tr>
                </table>
    
            </ul>            
</ul>
</body>
</html>
                             